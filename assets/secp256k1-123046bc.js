import{f as Nt}from"./index-1e8ba3d4.js";function Rt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function Se(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function se(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Ae(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Rt(t.outputLen),Rt(t.blockLen)}function Ie(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function _e(t,e){se(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ct={number:Rt,bool:Se,bytes:se,hash:Ae,exists:Ie,output:_e};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),M=(t,e)=>t<<32-e|t>>>e,Oe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Oe)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function qe(t){if(typeof t!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function Pt(t){if(typeof t=="string"&&(t=qe(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}function Ue(...t){if(!t.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(t.length===1)return t[0];const e=t.reduce((r,o)=>r+o.length,0),n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}class ie{clone(){return this._cloneInto()}}function ce(t){const e=r=>t().update(Pt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function fe(t=32){if(Nt&&typeof Nt.getRandomValues=="function")return Nt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Ne(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(n>>o&s),i=Number(n&s),c=r?4:0,a=r?0:4;t.setUint32(e+c,f,r),t.setUint32(e+a,i,r)}class Te extends ie{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Tt(this.buffer)}update(e){ct.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=Pt(e);const s=e.length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i===o){const c=Tt(e);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(e.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ct.exists(this),ct.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;Ne(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=Tt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,g=this.get();if(a>g.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,g[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=f,o%n&&e.buffer.set(r),e}}const Le=(t,e,n)=>t&e^~t&n,He=(t,e,n)=>t&e^t&n^e&n,$e=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=new Uint32Array(64);class ae extends Te{constructor(){super(64,32,8,!1),this.A=tt[0]|0,this.B=tt[1]|0,this.C=tt[2]|0,this.D=tt[3]|0,this.E=tt[4]|0,this.F=tt[5]|0,this.G=tt[6]|0,this.H=tt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[e,n,r,o,s,f,i,c]}set(e,n,r,o,s,f,i,c){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(e,n){for(let u=0;u<16;u++,n+=4)et[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const E=et[u-15],p=et[u-2],b=M(E,7)^M(E,18)^E>>>3,l=M(p,17)^M(p,19)^p>>>10;et[u]=l+et[u-7]+b+et[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:g}=this;for(let u=0;u<64;u++){const E=M(i,6)^M(i,11)^M(i,25),p=g+E+Le(i,c,a)+$e[u]+et[u]|0,l=(M(r,2)^M(r,13)^M(r,22))+He(r,o,s)|0;g=a,a=c,c=i,i=f+p|0,f=s,s=o,o=r,r=p+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,g=g+this.H|0,this.set(r,o,s,f,i,c,a,g)}roundClean(){et.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Re extends ae{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const pt=ce(()=>new ae);ce(()=>new Re);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ue=BigInt(0),St=BigInt(1),ke=BigInt(2),At=t=>t instanceof Uint8Array,Ce=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ht(t){if(!At(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Ce[t[n]];return e}function le(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function zt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function gt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(t.length%2)throw new Error("hex string is invalid: unpadded "+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=n*2,o=t.slice(r,r+2),s=Number.parseInt(o,16);if(Number.isNaN(s)||s<0)throw new Error("invalid byte sequence");e[n]=s}return e}function C(t){return zt(ht(t))}function Dt(t){if(!At(t))throw new Error("Uint8Array expected");return zt(ht(Uint8Array.from(t).reverse()))}const rt=(t,e)=>gt(t.toString(16).padStart(e*2,"0")),de=(t,e)=>rt(t,e).reverse(),Ve=t=>gt(le(t));function R(t,e,n){let r;if(typeof e=="string")try{r=gt(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else if(At(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function z(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!At(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function Ze(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function It(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function Pe(t){let e;for(e=0;t>ue;t>>=St,e+=1);return e}const ze=(t,e)=>t>>BigInt(e)&St,De=(t,e,n)=>t|(n?St:ue)<<BigInt(e),jt=t=>(ke<<BigInt(t-1))-St,Lt=t=>new Uint8Array(t),Jt=t=>Uint8Array.from(t);function he(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Lt(t),o=Lt(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>n(o,r,...u),c=(u=Lt())=>{o=i(Jt([0]),u),r=i(),u.length!==0&&(o=i(Jt([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const E=[];for(;u<e;){r=i();const p=r.slice();E.push(p),u+=r.length}return z(...E)};return(u,E)=>{f(),c(u);let p;for(;!(p=E(a()));)c();return f(),p}}const je={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function wt(t,e,n={}){const r=(o,s,f)=>{const i=je[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(f&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const Ke=Object.freeze(Object.defineProperty({__proto__:null,bitGet:ze,bitLen:Pe,bitMask:jt,bitSet:De,bytesToHex:ht,bytesToNumberBE:C,bytesToNumberLE:Dt,concatBytes:z,createHmacDrbg:he,ensureBytes:R,equalBytes:Ze,hexToBytes:gt,hexToNumber:zt,numberToBytesBE:rt,numberToBytesLE:de,numberToHexUnpadded:le,numberToVarBytesBE:Ve,utf8ToBytes:It,validateObject:wt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $=BigInt(0),T=BigInt(1),it=BigInt(2),Ye=BigInt(3),kt=BigInt(4),Ft=BigInt(5),te=BigInt(8);BigInt(9);BigInt(16);function H(t,e){const n=t%e;return n>=$?n:e+n}function Ge(t,e,n){if(n<=$||e<$)throw new Error("Expected power/modulo > 0");if(n===T)return $;let r=T;for(;e>$;)e&T&&(r=r*t%n),t=t*t%n,e>>=T;return r}function K(t,e,n){let r=t;for(;e-- >$;)r*=r,r%=n;return r}function Ct(t,e){if(t===$||e<=$)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=H(t,e),r=e,o=$,s=T;for(;n!==$;){const i=r/n,c=r%n,a=o-s*i;r=n,n=c,o=s,s=a}if(r!==T)throw new Error("invert: does not exist");return H(o,e)}function Me(t){const e=(t-T)/it;let n,r,o;for(n=t-T,r=0;n%it===$;n/=it,r++);for(o=it;o<t&&Ge(o,e,t)!==t-T;o++);if(r===1){const f=(t+T)/kt;return function(c,a){const g=c.pow(a,f);if(!c.eql(c.sqr(g),a))throw new Error("Cannot find square root");return g}}const s=(n+T)/it;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,g=i.pow(i.mul(i.ONE,o),n),u=i.pow(c,s),E=i.pow(c,n);for(;!i.eql(E,i.ONE);){if(i.eql(E,i.ZERO))return i.ZERO;let p=1;for(let l=i.sqr(E);p<a&&!i.eql(l,i.ONE);p++)l=i.sqr(l);const b=i.pow(g,T<<BigInt(a-p-1));g=i.sqr(b),u=i.mul(u,b),E=i.mul(E,g),a=p}return u}}function We(t){if(t%kt===Ye){const e=(t+T)/kt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%te===Ft){const e=(t-Ft)/te;return function(r,o){const s=r.mul(o,it),f=r.pow(s,e),i=r.mul(o,f),c=r.mul(r.mul(i,it),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Me(t)}const Xe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ge(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Xe.reduce((r,o)=>(r[o]="function",r),e);return wt(t,n)}function Qe(t,e,n){if(n<$)throw new Error("Expected power > 0");if(n===$)return t.ONE;if(n===T)return e;let r=t.ONE,o=e;for(;n>$;)n&T&&(r=t.mul(r,o)),o=t.sqr(o),n>>=T;return r}function Je(t,e){const n=new Array(e.length),r=e.reduce((s,f,i)=>t.is0(f)?s:(n[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return e.reduceRight((s,f,i)=>t.is0(f)?s:(n[i]=t.mul(s,n[i]),t.mul(s,f)),o),n}function Kt(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Fe(t,e,n=!1,r={}){if(t<=$)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=Kt(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=We(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:jt(o),ZERO:$,ONE:T,create:c=>H(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return $<=c&&c<t},is0:c=>c===$,isOdd:c=>(c&T)===T,neg:c=>H(-c,t),eql:(c,a)=>c===a,sqr:c=>H(c*c,t),add:(c,a)=>H(c+a,t),sub:(c,a)=>H(c-a,t),mul:(c,a)=>H(c*a,t),pow:(c,a)=>Qe(i,c,a),div:(c,a)=>H(c*Ct(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>Ct(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>Je(i,c),cmov:(c,a,g)=>g?a:c,toBytes:c=>n?de(c,s):rt(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?Dt(c):C(c)}});return Object.freeze(i)}function tn(t,e,n=!1){t=R("privateHash",t);const r=t.length,o=Kt(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);const s=n?Dt(t):C(t);return H(s,e-T)+T}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const en=BigInt(0),Ht=BigInt(1);function nn(t,e){const n=(o,s)=>{const f=s.negate();return o?f:s},r=o=>{const s=Math.ceil(e/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:n,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>en;)s&Ht&&(f=f.add(i)),i=i.double(),s>>=Ht;return f},precomputeWindow(o,s){const{windows:f,windowSize:i}=r(s),c=[];let a=o,g=a;for(let u=0;u<f;u++){g=a,c.push(g);for(let E=1;E<i;E++)g=g.add(a),c.push(g);a=g.double()}return c},wNAF(o,s,f){const{windows:i,windowSize:c}=r(o);let a=t.ZERO,g=t.BASE;const u=BigInt(2**o-1),E=2**o,p=BigInt(o);for(let b=0;b<i;b++){const l=b*c;let d=Number(f&u);f>>=p,d>c&&(d-=E,f+=Ht);const h=l,m=l+Math.abs(d)-1,B=b%2!==0,_=d<0;d===0?g=g.add(n(B,s[h])):a=a.add(n(_,s[m]))}return{p:a,f:g}},wNAFCached(o,s,f,i){const c=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function we(t){return ge(t.Fp),wt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Kt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function rn(t){const e=we(t);wt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:on,hexToBytes:sn}=Ke,ft={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ft;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:on(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ft,n=typeof t=="string"?sn(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=ft._parseInt(n.subarray(2)),{d:f,l:i}=ft._parseInt(s);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const g=a.toString(16);return g.length&1?`0${g}`:g},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,f=o.length/2,i=n(s),c=n(f);return`30${n(f+s+4)}02${c}${o}02${i}${r}`}},G=BigInt(0),L=BigInt(1),W=BigInt(2),xt=BigInt(3),ee=BigInt(4);function cn(t){const e=rn(t),{Fp:n}=e,r=e.toBytes||((b,l,d)=>{const h=l.toAffine();return z(Uint8Array.from([4]),n.toBytes(h.x),n.toBytes(h.y))}),o=e.fromBytes||(b=>{const l=b.subarray(1),d=n.fromBytes(l.subarray(0,n.BYTES)),h=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:d,y:h}});function s(b){const{a:l,b:d}=e,h=n.sqr(b),m=n.mul(h,b);return n.add(n.add(m,n.mul(b,l)),d)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(b){return typeof b=="bigint"&&G<b&&b<e.n}function i(b){if(!f(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(b){const{allowedPrivateKeyLengths:l,nByteLength:d,wrapPrivateKey:h,n:m}=e;if(l&&typeof b!="bigint"){if(b instanceof Uint8Array&&(b=ht(b)),typeof b!="string"||!l.includes(b.length))throw new Error("Invalid key");b=b.padStart(d*2,"0")}let B;try{B=typeof b=="bigint"?b:C(R("private key",b,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof b}`)}return h&&(B=H(B,m)),i(B),B}const a=new Map;function g(b){if(!(b instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,d,h){if(this.px=l,this.py=d,this.pz=h,l==null||!n.isValid(l))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(h==null||!n.isValid(h))throw new Error("z required")}static fromAffine(l){const{x:d,y:h}=l||{};if(!l||!n.isValid(d)||!n.isValid(h))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const m=B=>n.eql(B,n.ZERO);return m(d)&&m(h)?u.ZERO:new u(d,h,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const d=n.invertBatch(l.map(h=>h.pz));return l.map((h,m)=>h.toAffine(d[m])).map(u.fromAffine)}static fromHex(l){const d=u.fromAffine(o(R("pointHex",l)));return d.assertValidity(),d}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:l,y:d}=this.toAffine();if(!n.isValid(l)||!n.isValid(d))throw new Error("bad point: x or y not FE");const h=n.sqr(d),m=s(l);if(!n.eql(h,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){g(l);const{px:d,py:h,pz:m}=this,{px:B,py:_,pz:S}=l,x=n.eql(n.mul(d,S),n.mul(B,m)),v=n.eql(n.mul(h,S),n.mul(_,m));return x&&v}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:d}=e,h=n.mul(d,xt),{px:m,py:B,pz:_}=this;let S=n.ZERO,x=n.ZERO,v=n.ZERO,I=n.mul(m,m),D=n.mul(B,B),N=n.mul(_,_),O=n.mul(m,B);return O=n.add(O,O),v=n.mul(m,_),v=n.add(v,v),S=n.mul(l,v),x=n.mul(h,N),x=n.add(S,x),S=n.sub(D,x),x=n.add(D,x),x=n.mul(S,x),S=n.mul(O,S),v=n.mul(h,v),N=n.mul(l,N),O=n.sub(I,N),O=n.mul(l,O),O=n.add(O,v),v=n.add(I,I),I=n.add(v,I),I=n.add(I,N),I=n.mul(I,O),x=n.add(x,I),N=n.mul(B,_),N=n.add(N,N),I=n.mul(N,O),S=n.sub(S,I),v=n.mul(N,D),v=n.add(v,v),v=n.add(v,v),new u(S,x,v)}add(l){g(l);const{px:d,py:h,pz:m}=this,{px:B,py:_,pz:S}=l;let x=n.ZERO,v=n.ZERO,I=n.ZERO;const D=e.a,N=n.mul(e.b,xt);let O=n.mul(d,B),V=n.mul(h,_),Z=n.mul(m,S),X=n.add(d,h),w=n.add(B,_);X=n.mul(X,w),w=n.add(O,V),X=n.sub(X,w),w=n.add(d,m);let y=n.add(B,S);return w=n.mul(w,y),y=n.add(O,Z),w=n.sub(w,y),y=n.add(h,m),x=n.add(_,S),y=n.mul(y,x),x=n.add(V,Z),y=n.sub(y,x),I=n.mul(D,w),x=n.mul(N,Z),I=n.add(x,I),x=n.sub(V,I),I=n.add(V,I),v=n.mul(x,I),V=n.add(O,O),V=n.add(V,O),Z=n.mul(D,Z),w=n.mul(N,w),V=n.add(V,Z),Z=n.sub(O,Z),Z=n.mul(D,Z),w=n.add(w,Z),O=n.mul(V,w),v=n.add(v,O),O=n.mul(y,w),x=n.mul(X,x),x=n.sub(x,O),O=n.mul(X,V),I=n.mul(y,I),I=n.add(I,O),new u(x,v,I)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return p.wNAFCached(this,a,l,d=>{const h=n.invertBatch(d.map(m=>m.pz));return d.map((m,B)=>m.toAffine(h[B])).map(u.fromAffine)})}multiplyUnsafe(l){const d=u.ZERO;if(l===G)return d;if(i(l),l===L)return this;const{endo:h}=e;if(!h)return p.unsafeLadder(this,l);let{k1neg:m,k1:B,k2neg:_,k2:S}=h.splitScalar(l),x=d,v=d,I=this;for(;B>G||S>G;)B&L&&(x=x.add(I)),S&L&&(v=v.add(I)),I=I.double(),B>>=L,S>>=L;return m&&(x=x.negate()),_&&(v=v.negate()),v=new u(n.mul(v.px,h.beta),v.py,v.pz),x.add(v)}multiply(l){i(l);let d=l,h,m;const{endo:B}=e;if(B){const{k1neg:_,k1:S,k2neg:x,k2:v}=B.splitScalar(d);let{p:I,f:D}=this.wNAF(S),{p:N,f:O}=this.wNAF(v);I=p.constTimeNegate(_,I),N=p.constTimeNegate(x,N),N=new u(n.mul(N.px,B.beta),N.py,N.pz),h=I.add(N),m=D.add(O)}else{const{p:_,f:S}=this.wNAF(d);h=_,m=S}return u.normalizeZ([h,m])[0]}multiplyAndAddUnsafe(l,d,h){const m=u.BASE,B=(S,x)=>x===G||x===L||!S.equals(m)?S.multiplyUnsafe(x):S.multiply(x),_=B(this,d).add(B(l,h));return _.is0()?void 0:_}toAffine(l){const{px:d,py:h,pz:m}=this,B=this.is0();l==null&&(l=B?n.ONE:n.inv(m));const _=n.mul(d,l),S=n.mul(h,l),x=n.mul(m,l);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:_,y:S}}isTorsionFree(){const{h:l,isTorsionFree:d}=e;if(l===L)return!0;if(d)return d(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:d}=e;return l===L?this:d?d(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return ht(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const E=e.nBitLength,p=nn(u,e.endo?Math.ceil(E/2):E);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function fn(t){const e=we(t);return wt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function an(t){const e=fn(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function f(w){return G<w&&w<n.ORDER}function i(w){return H(w,r)}function c(w){return Ct(w,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:g,weierstrassEquation:u,isWithinCurveOrder:E}=cn({...e,toBytes(w,y,A){const U=y.toAffine(),q=n.toBytes(U.x),k=z;return A?k(Uint8Array.from([y.hasEvenY()?2:3]),q):k(Uint8Array.from([4]),q,n.toBytes(U.y))},fromBytes(w){const y=w.length,A=w[0],U=w.subarray(1);if(y===o&&(A===2||A===3)){const q=C(U);if(!f(q))throw new Error("Point is not on curve");const k=u(q);let j=n.sqrt(k);const P=(j&L)===L;return(A&1)===1!==P&&(j=n.neg(j)),{x:q,y:j}}else if(y===s&&A===4){const q=n.fromBytes(U.subarray(0,n.BYTES)),k=n.fromBytes(U.subarray(n.BYTES,2*n.BYTES));return{x:q,y:k}}else throw new Error(`Point of length ${y} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),p=w=>ht(rt(w,e.nByteLength));function b(w){const y=r>>L;return w>y}function l(w){return b(w)?i(-w):w}const d=(w,y,A)=>C(w.slice(y,A));class h{constructor(y,A,U){this.r=y,this.s=A,this.recovery=U,this.assertValidity()}static fromCompact(y){const A=e.nByteLength;return y=R("compactSignature",y,A*2),new h(d(y,0,A),d(y,A,2*A))}static fromDER(y){const{r:A,s:U}=ft.toSig(R("DER",y));return new h(A,U)}assertValidity(){if(!E(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!E(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new h(this.r,this.s,y)}recoverPublicKey(y){const{r:A,s:U,recovery:q}=this,k=v(R("msgHash",y));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const j=q===2||q===3?A+e.n:A;if(j>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=q&1?"03":"02",Q=a.fromHex(P+p(j)),J=c(j),at=i(-k*J),bt=i(U*J),F=a.BASE.multiplyAndAddUnsafe(Q,at,bt);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return gt(this.toDERHex())}toDERHex(){return ft.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return gt(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const m={isValidPrivateKey(w){try{return g(w),!0}catch{return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const w=e.randomBytes(n.BYTES+8),y=tn(w,r);return rt(y,e.nByteLength)},precompute(w=8,y=a.BASE){return y._setWindowSize(w),y.multiply(BigInt(3)),y}};function B(w,y=!0){return a.fromPrivateKey(w).toRawBytes(y)}function _(w){const y=w instanceof Uint8Array,A=typeof w=="string",U=(y||A)&&w.length;return y?U===o||U===s:A?U===2*o||U===2*s:w instanceof a}function S(w,y,A=!0){if(_(w))throw new Error("first arg must be private key");if(!_(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(g(w)).toRawBytes(A)}const x=e.bits2int||function(w){const y=C(w),A=w.length*8-e.nBitLength;return A>0?y>>BigInt(A):y},v=e.bits2int_modN||function(w){return i(x(w))},I=jt(e.nBitLength);function D(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(G<=w&&w<I))throw new Error(`bigint expected < 2^${e.nBitLength}`);return rt(w,e.nByteLength)}function N(w,y,A=O){if(["recovered","canonical"].some(st=>st in A))throw new Error("sign() legacy options not supported");const{hash:U,randomBytes:q}=e;let{lowS:k,prehash:j,extraEntropy:P}=A;k==null&&(k=!0),w=R("msgHash",w),j&&(w=R("prehashed msgHash",U(w)));const Q=v(w),J=g(y),at=[D(J),D(Q)];if(P!=null){const st=P===!0?q(n.BYTES):P;at.push(R("extraEntropy",st,n.BYTES))}const bt=z(...at),F=Q;function Ut(st){const ut=x(st);if(!E(ut))return;const Wt=c(ut),lt=a.BASE.multiply(ut).toAffine(),Y=i(lt.x);if(Y===G)return;const dt=i(Wt*i(F+Y*J));if(dt===G)return;let Xt=(lt.x===Y?0:2)|Number(lt.y&L),Qt=dt;return k&&b(dt)&&(Qt=l(dt),Xt^=1),new h(Y,Qt,Xt)}return{seed:bt,k2sig:Ut}}const O={lowS:e.lowS,prehash:!1},V={lowS:e.lowS,prehash:!1};function Z(w,y,A=O){const{seed:U,k2sig:q}=N(w,y,A);return he(e.hash.outputLen,e.nByteLength,e.hmac)(U,q)}a.BASE._setWindowSize(8);function X(w,y,A,U=V){var lt;const q=w;if(y=R("msgHash",y),A=R("publicKey",A),"strict"in U)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:j}=U;let P,Q;try{if(typeof q=="string"||q instanceof Uint8Array)try{P=h.fromDER(q)}catch(Y){if(!(Y instanceof ft.Err))throw Y;P=h.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:Y,s:dt}=q;P=new h(Y,dt)}else throw new Error("PARSE");Q=a.fromHex(A)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&P.hasHighS())return!1;j&&(y=e.hash(y));const{r:J,s:at}=P,bt=v(y),F=c(at),Ut=i(bt*F),st=i(J*F),ut=(lt=a.BASE.multiplyAndAddUnsafe(Q,Ut,st))==null?void 0:lt.toAffine();return ut?i(ut.x)===J:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:S,sign:Z,verify:X,ProjectivePoint:a,Signature:h,utils:m}}function un(t,e){const n=t.ORDER;let r=G;for(let E=n-L;E%W===G;E/=W)r+=L;const o=r,s=(n-L)/W**o,f=(s-L)/W,i=W**o-L,c=W**(o-L),a=t.pow(e,s),g=t.pow(e,(s+L)/W);let u=(E,p)=>{let b=a,l=t.pow(p,i),d=t.sqr(l);d=t.mul(d,p);let h=t.mul(E,d);h=t.pow(h,f),h=t.mul(h,l),l=t.mul(h,p),d=t.mul(h,E);let m=t.mul(d,l);h=t.pow(m,c);let B=t.eql(h,t.ONE);l=t.mul(d,g),h=t.mul(m,b),d=t.cmov(l,d,B),m=t.cmov(h,m,B);for(let _=o;_>L;_--){let S=W**(_-W),x=t.pow(m,S);const v=t.eql(x,t.ONE);l=t.mul(d,b),b=t.mul(b,b),x=t.mul(m,b),d=t.cmov(l,d,v),m=t.cmov(x,m,v)}return{isValid:B,value:d}};if(t.ORDER%ee===xt){const E=(t.ORDER-xt)/ee,p=t.sqrt(t.neg(e));u=(b,l)=>{let d=t.sqr(l);const h=t.mul(b,l);d=t.mul(d,h);let m=t.pow(d,E);m=t.mul(m,h);const B=t.mul(m,p),_=t.mul(t.sqr(m),l),S=t.eql(_,b);let x=t.cmov(B,m,S);return{isValid:S,value:x}}}return u}function ln(t,e){if(ge(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=un(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,g,u;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,e.B),i=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,e.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,e.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,e.B),s=t.add(s,c),g=t.mul(o,f);const{isValid:E,value:p}=n(s,a);u=t.mul(o,r),u=t.mul(u,p),g=t.cmov(g,f,E),u=t.cmov(u,p,E);const b=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,b),g=t.div(g,i),{x:g,y:u}}}function dn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return It(t);throw new Error("DST must be Uint8Array or string")}const hn=C;function nt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function gn(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function yt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Yt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function wn(t,e,n,r){yt(t),yt(e),Yt(n),e.length>255&&(e=r(z(It("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:s}=r,f=Math.ceil(n/o);if(f>255)throw new Error("Invalid xmd length");const i=z(e,nt(e.length,1)),c=nt(0,s),a=nt(n,2),g=new Array(f),u=r(z(c,t,a,nt(0,1),i));g[0]=r(z(u,nt(1,1),i));for(let p=1;p<=f;p++){const b=[gn(u,g[p-1]),nt(p+1,1),i];g[p]=r(z(...b))}return z(...g).slice(0,n)}function bn(t,e,n,r,o){if(yt(t),yt(e),Yt(n),e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(It("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(nt(n,2)).update(e).update(nt(e.length,1)).digest()}function ne(t,e,n){wt(n,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:f,expand:i,DST:c}=n;yt(t),Yt(e);const a=dn(c),g=r.toString(2).length,u=Math.ceil((g+o)/8),E=e*s*u;let p;if(i==="xmd")p=wn(t,a,E,f);else if(i==="xof")p=bn(t,a,E,o,f);else if(i==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');const b=new Array(e);for(let l=0;l<e;l++){const d=new Array(s);for(let h=0;h<s;h++){const m=u*(h+l*s),B=p.subarray(m,m+u);d[h]=H(hn(B),r)}b[l]=d}return b}function yn(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,f,i,c]=n.map(a=>a.reduce((g,u)=>t.add(t.mul(g,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function mn(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=ne(r,2,{...n,DST:n.DST,...o}),f=t.fromAffine(e(s[0])),i=t.fromAffine(e(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=ne(r,1,{...n,DST:n.encodeDST,...o}),f=t.fromAffine(e(s[0])).clearCofactor();return f.assertValidity(),f}}}class be extends ie{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ct.hash(e);const r=Pt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return ct.exists(this),this.iHash.update(e),this}digestInto(e){ct.exists(this),ct.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ye=(t,e,n)=>new be(t,e).update(n).digest();ye.create=(t,e)=>new be(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pn(t){return{hash:t,hmac:(e,...n)=>ye(t,e,Ue(...n)),randomBytes:fe}}function xn(t,e){const n=r=>an({...t,...pn(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Et=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),me=BigInt(1),Bt=BigInt(2),re=(t,e)=>(t+e/Bt)/e;function pe(t){const e=_t,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%e,g=a*a*t%e,u=K(g,n,e)*g%e,E=K(u,n,e)*g%e,p=K(E,Bt,e)*a%e,b=K(p,o,e)*p%e,l=K(b,s,e)*b%e,d=K(l,i,e)*l%e,h=K(d,c,e)*d%e,m=K(h,i,e)*l%e,B=K(m,n,e)*g%e,_=K(B,f,e)*b%e,S=K(_,r,e)*a%e,x=K(S,Bt,e);if(!ot.eql(ot.sqr(x),t))throw new Error("Cannot find square root");return x}const ot=Fe(_t,void 0,void 0,{sqrt:pe}),Ot=xn({a:BigInt(0),b:BigInt(7),Fp:ot,n:Et,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Et,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-me*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),i=re(s*t,e),c=re(-r*t,e);let a=H(t-i*n-c*o,e),g=H(-i*r-c*s,e);const u=a>f,E=g>f;if(u&&(a=e-a),E&&(g=e-g),a>f||g>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:E,k2:g}}}},pt),qt=BigInt(0),xe=t=>typeof t=="bigint"&&qt<t&&t<_t,En=t=>typeof t=="bigint"&&qt<t&&t<Et,oe={};function vt(t,...e){let n=oe[t];if(n===void 0){const r=pt(Uint8Array.from(t,o=>o.charCodeAt(0)));n=z(r,r),oe[t]=n}return pt(z(n,...e))}const Gt=t=>t.toRawBytes(!0).slice(1),Vt=t=>rt(t,32),$t=t=>H(t,_t),mt=t=>H(t,Et),Mt=Ot.ProjectivePoint,Bn=(t,e,n)=>Mt.BASE.multiplyAndAddUnsafe(t,e,n);function Zt(t){let e=Ot.utils.normPrivateKeyToScalar(t),n=Mt.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:mt(-e),bytes:Gt(n)}}function Ee(t){if(!xe(t))throw new Error("bad x: need 0 < x < p");const e=$t(t*t),n=$t(e*t+BigInt(7));let r=pe(n);r%Bt!==qt&&(r=$t(-r));const o=new Mt(t,r,me);return o.assertValidity(),o}function Be(...t){return mt(C(vt("BIP0340/challenge",...t)))}function vn(t){return Zt(t).bytes}function Sn(t,e,n=fe(32)){const r=R("message",t),{bytes:o,scalar:s}=Zt(e),f=R("auxRand",n,32),i=Vt(s^C(vt("BIP0340/aux",f))),c=vt("BIP0340/nonce",i,o,r),a=mt(C(c));if(a===qt)throw new Error("sign failed: k is zero");const{bytes:g,scalar:u}=Zt(a),E=Be(g,o,r),p=new Uint8Array(64);if(p.set(g,0),p.set(Vt(mt(u+E*s)),32),!ve(p,r,o))throw new Error("sign: Invalid signature produced");return p}function ve(t,e,n){const r=R("signature",t,64),o=R("message",e),s=R("publicKey",n,32);try{const f=Ee(C(s)),i=C(r.subarray(0,32));if(!xe(i))return!1;const c=C(r.subarray(32,64));if(!En(c))return!1;const a=Be(Vt(i),Gt(f),o),g=Bn(f,c,mt(-a));return!(!g||!g.hasEvenY()||g.toAffine().x!==i)}catch{return!1}}const qn={getPublicKey:vn,sign:Sn,verify:ve,utils:{randomPrivateKey:Ot.utils.randomPrivateKey,lift_x:Ee,pointToBytes:Gt,numberToBytesBE:rt,bytesToNumberBE:C,taggedHash:vt,mod:H}},An=yn(ot,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))),In=ln(ot,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ot.create(BigInt("-11"))}),{hashToCurve:Un,encodeToCurve:Nn}=mn(Ot.ProjectivePoint,t=>{const{x:e,y:n}=In(ot.create(t[0]));return An(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ot.ORDER,m:1,k:128,expand:"xmd",hash:pt});export{Nn as encodeToCurve,Un as hashToCurve,qn as schnorr,Ot as secp256k1};
